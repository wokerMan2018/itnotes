[TOC]

# 简介

## 概念

Shell 是一个用 C 语言编写的程序，Shell 既是一种命令语言，又是一种程序设计语言。

> Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。
>
> Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。

- shell分类
   - Bourne：常见的是sh(Bourne Shell)和bash(Bourne Again Shell)，还有fish、zsh等等
   - C：cshell、tcsh（BSD的Unix)

  以下以bash为默认shell。

- shell查看

  ```shell
  echo $SHELL    #查看当前使用的shell
  cat /etc/shells    #查看当前系统支持的shell
  ```

- 扩展名sh：脚本文件**可以不使用扩展名** （但是使用扩展名sh，shell可以为代码提供颜色高亮）。

- 解释器：在脚本文件开始时使用shebang指定解释器，例如`#!/bin/sh`指定sh作为解释器。

  shebang，即sharp--`#`和ban--`!`的联合缩写。

- 为脚本添加执行权限：`chmod +x file.sh`。

- 执行脚本：

  - 脚本有可执行权限：`./file.sh``
  - 脚本无可执行权限：``bash file.sh`

- 命令别名alias

  示例：`alias ll='ls -al --color=auto'`  使用ll别名替代`ls -al --color=auto`这条命令，仅临时生效。

  可以在配置文件如`~/.bashr`中使用alias设置别名，使得该别名在当前用户下一直生效。

  添加别名后，使用`source ~/.bashrc`可使其立即生效。

- 命令优先级顺序：绝对/相对路径执行命令 > 别名 > bash内部命令 > $PATH环境变量定义的目录查找顺序的第一个命令 。

# 基础

## 基本特殊符号

- `#`：注释符号。
- `\`：反斜杠，转义符，将后一个特殊字符转为普通字符。
- 命令替换：在命令行中使用命令的输出来替换特定的命令。

  - `$()`：括号内部的内容是系统命令，会最先执行。（推荐使用）
  - ``：反引号是旧式遗留的写法，其内部的反斜杠无转义功能。（不推荐使用）
- `()`：子命令组，**另开一个子shell**顺序执行，其中的变量不能够被外面部分使用。
- 路径

  - `/` ：斜杠，路径分隔符。
  - 路径简写
    - `~`：当前用户的家目录
    - `-`：当前用户的上次工作目录
    - `..`：上一级目录
    - `.`：当前目录
- 引号

  - 单引号`' '`：引号内特殊字符**均无**特殊意义。
  - 双引号`" "`： 引号中除了` $ \ ""  （反引号、美元符号、反斜杠和双引号）外的特殊字符无特殊意义。​	

- `&`：将命令放入后台执行。
- `:`：空命令。

上述特殊字符与其他字符组合成的特殊意义（如`\`加上一些字符成为特殊意义的[控制符](#控制符) ），以及其余特殊符号，归入后文各相关章节叙述。

## 多命令执行符号

### 逻辑符

- `; `  分号-- `a;b`   各命令间没有逻辑关系影响
- `&& `   逻辑与--`a&&b`    前面的命令正确执行，才能执行后面的命令
- `||`    逻辑或--`a||b`    前面的命令不能正确执行，就执行后面的命令

### 管道符

管道符pipeline  `|`

- 管道命令只处理前一个命令正确输出，不处理错误输出。（参看[标准输出重定向](#重定向)）

- 管道命令右边命令，必须能够接收标准输入流命令。 

 `a|b`    管道符前面命令a的**正确输出**，作为管道符后面命令b的操作对象。

## 通配符

- `?`    匹配1个字符

- `*`    匹配任意个数字符

  特别的：

  ```shell
  x=*
  echo $x  #打印出当前目录下所有文件（夹）名 ，与echo *输出一致
  ```

- `[]`    匹配括号内任意一个字符（如`[ab]`匹配a或b或c）
  - `[-]`   匹配在编码顺序内的所有字符（如`[a-z]`匹配a到z的字母）
  - `[!]`    匹配**除了**`!`后面字符的其他字符（如`[!abc]`匹配除了abc的字符）

通配符与正则表达式见后文[正则表达式](#正则表达式) 。

## 控制符

[echo输出](#echo输出)命令中使用`-e`启用控制符

注意：退格键\b并不会在内容中删除\b前面一个字符，它**只是让光标**向前**移动**一格而已，回车键\r同理。

|   控制符   | 意义                                    |
| :--------: | :-------------------------------------- |
| \a 或 \007 | 警告声/响铃（alert bell）               |
|  \b或\010  | 退格（backspace）                       |
|  \E或\033  | 退出/取消（escpae）                     |
|  \f或\014  | 换页符（formfeed）                      |
|  \n或\012  | 换行符（new line）                      |
|  \r或\012  | 回车（return）                          |
|  \t或\011  | 表格跳位/制表符（tab）                  |
|     \v     | 垂直表格跳位/垂直制表符（vertical tab） |
|     \c     | 取消行末换行符 （cancel）               |
|   \0nnn    | 八进制数(nnn表示八进制数)               |
|    \xhh    | 十六进制数(hh表示十六进制数)            |
| \e[或\033[ | 字符转义为ANSI escape code              |

### ANSI escape code

`\e[`或`\033`是CSI，全称为“控制序列引导器”（Control Sequence Introducer/Initiator），能将字符转义成[ANSI escape code](https://en.wikipedia.org/wiki/ANSI_escape_code)

#### 显示样式和颜色

写法：在样式或颜色之后要使用m，如`1m`，如果使用颜色和样式，二者以`;`分隔，只在第二个数字后写上m即可，例如：`echo -e '\e[1;35m文字文字\e[0m'` 。

这些样式和颜色值是ANSI escape code中的[SGR](https://en.wikipedia.org/wiki/ANSI_escape_code#CSI_codes) ，某些SGR码支持并不广泛，以下列出常见SGR code。

- 样式：
|  样式  |  加粗  |  弱化  |  斜体  | 下划线  |  闪烁  |  反色  |  隐藏  | 删除线  |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  开启  |  1   |  2   |  3   |  4   |  5   |  7   |  8   |  9   |
|  关闭  |  21  |  22  |  23  |  24  |  25  |  27  |  28  |  29  |
**0恢复默认**样式。2弱化是指显示的颜色和粗细强度等减弱，22关闭弱化即使用普通效果（normal）。21具有关闭粗体或者设置双下划线的效果，不过几乎不被支持。

此外：6/26（快速闪烁，每分钟闪烁150+次）较少被支持；10用于设置首选字体，11-19设置其他代替字体，20设置哥特体。

- 颜色
|  颜色  |  黑   |  红   |  绿   |  黄   |  蓝   |  洋红  |  青   |  白   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 前景色  |  30  |  31  |  32  |  33  |  34  |  35  |  36  |  37  |
| 背景色  |  40  |  41  |  42  |  43  |  44  |  45  |  46  |  47  |

此外：38默认的前景颜色上设置下划线    39默认的前景颜色上关闭下划线    49默认背景色

#### 光标位置和键盘控制

参看ANSI escape code中中[CSI code](https://en.wikipedia.org/wiki/ANSI_escape_code#CSI_codes)

- 光标位置

| 字符内容      | 光标位置说明         |
| :-------- | :------------- |
| \033[nA   | 上移n行           |
| \033[nB   | 下移n行           |
| \033[nC   | 右移n行           |
| \033[nD   | 左移n行           |
| \033[y;xH | 设置光标位置（第y行第x列） |
| \033[K    | 清除从光标到行尾的内容    |
| \033[s    | 保存光标位置         |
| \033[u    | 恢复光标位置         |
| \033[?25l | 隐藏光标           |
| \033[?25h | 显示光标           |
| \033[2J   | 清除屏幕           |

- 键盘控制
  - \033[0q         　关闭所有的键盘指示灯 
  - \033[1q         　设置“滚动锁定”指示灯 (Scroll Lock) 
  - \033[2q         　设置“数值锁定”指示灯 (Num Lock) 
  - \033[3q         　设置“大写锁定”指示灯 (Caps Lock) 

## 重定向

### 标准输入/输出/错误输出

重定向指使用文件代替标准输入、标准输出和标准错误输出。

| 类型                  | 代码 | 运算符        |
| --------------------- | ---- | ------------- |
| 标准输入 (stdin)      | 0    | `<`           |
| 标准输出 (stdout)     | 1    | `>` 或 `>>`   |
| 标准错误输出 (stderr) | 2    | `2>` 或 `2>>` |

`>`表示覆盖方式重定向，`>>`表示追加方式重定向。

如果需要将标准输出(stdout)和标准错误输出(stderr)同时重定向到一个文件，可将其中一个输出转换为另一个输出。如 `2>&1` 表示将标准错误输出转换为标准输出。

如果希望执行某个命令，但又不希望输出结果:

- `command > /dev/null`   - `/dev/null`是一个空文件
- `command > /dev/zero`   - `/dev/zero`是一个无显示的无限输入文件

`<` 表示从标准输入读取文件

```shell
~ $ wc -l /etc/environment
9 /etc/environment
#从标准输入读取内容再交由wc处理
~ $ wc -l < /etc/environment  #类似cat /etc/environment | wc -l
9
```

### Here Document和Here Strings

- Here Document：`<<`用来将输入重定向到一个交互式 Shell 脚本或程序，两个标志（可以是任意名字，`EOF` 是一个常被使用的标志名）之间的内容作为输入内容交由`<<`前面的命令处理。

  `<<`后面添加`-`，即`<<-`会忽略行首的制表符。

  ```shell
  ~ $ cat << EOF
      Hello
      shell
  EOF
  2          # 输出结果为 2 行
  ```

- Here Strings：`<<<`后面的字符串作为标准输入交由前面的命令处理。

  ```shell
  ~ $ tr a-z A-Z <<< 'hello shell'
  HELLO SHELL
  ```

### tee

tee可以将数据重定向到给定文件和屏幕上。

常用参数：

- `-a`：向文件中重定向时使用追加模式
- `-i`：忽略中断（interrupt）信号

```shell
who | tee users.txt
echo "alias rm='mv'" | tee -a .bashrc
```

## 输出输入命令

### echo输出

选项：

-  `-e`   启用[控制符](#控制符)转换
-  `-E`  关闭[控制符](#控制符)转换
-  `-n`  取消行末换行符（同[控制符](#控制符)中`\c` ）

输出的内容最好加上引号，否则在某些情况下会出问题（如使用空格、控制符号等的时候）。
```shell
echo a  #输出test
echo a\nb    #输出anb
echo -e 'a\nb'    #输出a (换行) b
```

### printf输出

printf 命令模仿 C 程序库（library）里的 printf() 程序，使用printf的脚本比使用echo移植性好。

**默认printf不会像 echo 在输出内容尾部自动添加换行符**，需要手动添加 `\n`。

```shell
$ printf "Hello, Shell\n"
Hello, Shell
```

printf可是使用格式化字符串：`printf format-string [arguments...]`

格式化

参数：

- format-string： 为格式控制字符串
- arguments：为参数列表。

例如脚本内容：

```shell
#!/bin/sh
printf "%-10s %-8s %-4s\n" 姓名 性别 身高
printf "%-10s %-8s %-4.2f\n" 人甲 男 177.7 
printf "%-10s %-8s %-4.2f\n" 人乙 女 168.8 
```

将输出：

```shell
姓名     性别   身高
人甲     男      177.7
人乙     女      168.8
```

### read输入

选项：

- -p   提示信息
- -t    等待时间（单位：秒）
- -d   持续读取直到读入定界符（delimiter）为止
- -r    不允许反斜杠转义任何字符
- -n   指定接收输入的字符数
- -s    不显示输入的数据，用于机密信息的输入（如密码）

```shell
read -p "please input username:"
read -s -p "please input password:"
read -p "请输入名字：" name  #将用户的输入内容赋值给name变量
#使用-d -r 将多行内容存到一个变量中
read -d -r '' msg << TIP
You should reboot system after installation.\n
Good Luck!\n
TIP
echo $msg    #将会输出那两行提示内容 TIP是界定符 两个TIP间的内容被存到msg变量中
```

# 变量

shell中变量直接赋值即可生成，使用$作前缀调用变量。

## 变量分类

- 按数据类型划分
  - 字符串
  - 整型数字
  - 浮点型数字
  - 日期
- 以整个Linux操作系统为准，可如下分类
  - **用户自定义**变量
  - [环境变量](#环境变量)：保存和系统环境相关的数据；对系统生效的环境变量名和变量作用是固定的。`env`可查询当前环境变量。
  - [预定义变量](#预定义变量)：shell中（如bash中）已经定义好的变量，变量名不能自定义，变量作用固定。
  - [位置参数变量](#位置参数变量)：向脚本中传递参数或数据，变量名不能自定义，变量作用固定。
- 按作用域划分
  - 局部变量

    使用`local 变量名=值 `关键字定义局部变量，仅作用于函数内

  - 全局变量

    Shell函数的变量**默认是全局变量**。

### 用户自定义变量

- 定义变量：`变量名=值`，如`var1=123`
  - **首个字符必须为字母**（a-z，A-Z）。
  - 中间不能有空格，可以使用下划线（_）。
  - **不能使用标点符号**。
  - 不能使用shell里的关键字（可用help命令查看保留关键字）。
  - 赋值符号`=`**两边不能有空格**
  - 包含空白字符的值要使用引号（参看[基本特殊符号](#基本特殊符号)中单双引号的区别）  示例`'a b c'`
- 删除变量：`unset 变量名 `


- 查询变量：`set 变量名`

- 调用变量：`$变量名`或`${变量名}`，如 `$var1`或者`${var1}` 

  无大括号是简写方法，需要**使用`{}`的情况**：

  - 如果变量后面跟一个**非小写字符串、数字或下划线**   `${var}_1`
  - [位置参数变量](#位置参数变量)中**第10个及以后的参数的写法**
  - 增加可读性或避免混淆  例如`${var}test`和`$vartest`

### 环境变量

主要的几个环境变量配置文件：

- /etc/profie
- /etc/profile.d/*
- ~/.bash_profile
- ~/.bashrc
- /etc/bashrc

配置文件修改后立即生效，使用source，示例

```shell
source ~/.bashrc
#或者
. ~/.bashrc
```

### 预定义变量

| 预定义变量 | 说明                                                       |
| ---------- | ---------------------------------------------------------- |
| $?         | 返回最后一次执行的命令返回的状态码（0执行正确，1执行错误） |
| $$         | 当前进程号（PID）                                          |
| $!         | 后台运行的最后一个进程的进程号（PID）                      |

附常用状态码：
- 0 	命令成功结束
- 1 	通用未知错误
- 2 	误用shell命令
- 126 	命令不可执行
- 127 	没找到命令
- 128 	无效退出参数
- 130 	通过Ctrl + C 终止

### 位置参数变量

| 位置参数变量 | 说明                                                     |
| :----------- | :------------------------------------------------------- |
| ${n}         | 第n个参数，0代表命令行本身，第0至9个参数可省略括号如`$0` |
| $*           | **所有参数的集合**                                       |
| $@           | **所有参数的集合**                                       |
| $#           | 所有参数的个数                                           |

`$*`和`$@`添加双引号的差异：

- `"$*"`和`$*`作用一致：丢弃传入参数的引号而**展开传入参数**。

- `"$@"`和`$@`（建议使用）

  - 使用双引号：传入参数是一个整体而不进行展开
  - 不使用双引号：丢弃传入参数的双引号而展开传入参数——同`$*`和`"$*"`

  例如传入的参数`"a b" c `时，

  `$@`（`"$*"`和`$*`）：视作`a`、`b`和`c`三个参数

  `"$@"`：视作`"a b"`和`c`两个参数

## declare声明变量类型

用于变量类型声明。如不声明，变量默认类型是字符串。
选项：

- `-`    给变量设定类型属性
- `+`    取消变量的类型属性
- -a    将变量声明为**数组**型
- -i     将变量声明为**整数**型
- -x    将变量声明为**环境变量**
- -r    将变量声明为**只读**类型
- -p    **显示**指定变量的被声明的**类型**
- -f     仅显示函数

## 变量测试

| 变量置换方式        | 变量y没有设置    | 变量y为空值     | 变量           |
| ------------- | ---------- | ---------- | ------------ |
| `x=${y-新值} `  | x=新值       | x为空        | `x=$y`       |
| `x=${y:-新值}`  | x=新值       | x=新值       | `x=$y`       |
| `x=${y+新值}`   | x为空        | x=新值       | x=新值         |
| `x=${y:+新值}`  | x为空        | x为空        | x=新值         |
| `x=${y=新值}`   | x=新值 y=新值  | x为空 y值不变   | `x=$y`  y值不变 |
| `x=${y:=新值}`  | x=新值 y=新值  | x=新值 y=新值  | `x=$y`  y值不变 |
| `x=${y?新值}`   | 新值（标准错误）输出 | x值为空       | `x=$y`       |
| `x=${y:?新值} ` | 新值（标准错误）输出 | 新值（标准错误）输出 | `x=$y`       |

# 数组

Bash Shell 只支持一维数组。

- 定义数组
  - 直接列出所有元素：`数组名=(元素0 元素1 ... 元素n)`， 使用空格隔开各个元素。
  - 直接对某个元素赋值：`数组名[下标]=值`　（将自动创建数组）

  ```shell
  array1=(1 2 3 4 5)
  array2[1]=123
  array2[2]=567
  ```


- 读取数组
  - 某个数组元素：`${数组名[下标]}`
  - 数组所有元素：`${数组名[*]}`或`${数组名[@]}`
  - 数组长度：`${#数组名[*]}`或`${#数组名[@]}`  （比读取数组所有元素多一个`#` ）

  ```shell
  echo ${array1[0]}
  echo ${array2[@]}
  echo ${#array2[@]}
  ```

提示：字符串亦可以使用读取数组的方法获取字串信息

```shell
str=abcd
echo ${abcd[1]}  #a
echo ${abcd[@]}  #abcd
echo ${#abcd[@]}  #4
```



# 运算符

shell运算符包括：算数运算符、关系运算符、布尔运算符、字符串运算符和文件测试运算符。

## 算术运算符

同多数是编程语言一致，不再列出。**shell变量默认类型为字符串**，可使用以下方法进行数值运算（主要是整数运算）。

### 整数运算

- `(())`表达式

  ```shell
  a=1
  b=2
  c=$(($a+$b))  #c为3
  ((b+=2))  #b为4
  ```


- `$[]`表达式

  ```shell
  var=1
  var=$[$var+1]
  echo $var
  ```


- `declare`命令

  ```shell
  a=1
  declare -i c = $a + 1  #声明为整数
  echo c    #c为2
  ```


- `expr`命令

  - 只能进行整数运算
  - expr命令后把的算式中，**操作符和操作数之间必须有空格**

  ```shell
  expr 17 \* 6    #102  整数运算  #要使用\对*进行转
  expr $var1 + $var2  #注意加号两侧空格
  ```


  此外`expr`还能操作字符串：

  ```shell
  expr length "string"    #6  字符串长度
  expr substr "this-string" 3 5    #is  在[3,5)区间查找字符串
  expr index "string" s   #1  s第一次出现的位置
  ```

- `let`命令

  - 只能进行整数运算
  - 操作符和操作数之间**不能有空格**

  ```shell
  let a=1+1    #a为2
  let a++	   #a为3
  let a-=2    #a为1
  echo $a   # 1
  ```

### 浮点数运算

- bc命令

  直接执行bc可以进入bc的交互命令行，直接使用即可，下不赘述bc的交互式命令行计算方法。

  ```shell
  #普通四则运算
  echo "1+1-1*1/1"|bc  #1
  #幂运算
  echo "2^10"|bc #1024
  #开方运算
  echo "sqrt(100)"|bc  #10
  ```

  - 浮点数精度

    ```shell
    echo "0.1+0.9"|bc  #1.0
    #scale设置小数精度
    echo "scale=2;1/3"|bc  #.33
    ```

  - 进制转换

    ```shell
    echo "obase=2;3"|bc  #十进制3转为二进制 结果为11
    echo "obase=10;ibase=2;11"|bc  #2进制11转为十进制 结果为3
    ```

    - ibase指明原数的进制（i, input默认十进制，十进制时可省略）
    - obase指明要目标进制（o, output）

## (数字大小）关系运算符

**关系运算符只支持数字**，不支持字符串，除非字符串的值是数字。(字符串参看[字符串运算符](#字符串运算符))

`数字1 选项 数字2`根据各选项，将第一个数和第二个数对比，判断对比情况，返回true/false。

|  选项  | 说明                            |
| :--: | :---------------------------- |
| -eq  | 是否相等（equal）                   |
| -ne  | 是否不等（not equal）               |
| -gt  | 是否更大（greater than）            |
| -lt  | 是否更小（less than）               |
| -ge  | 是否大于等于（greater than or equal） |
| -le  | 是否小于等于（less than or equal）    |

## 字符串运算符

空和非空：`选项 字符串（或变量）` ；等和不等：`字符串1 选项 字符串2` ，根据各选项判断字符串情况，返回true或false。

|  选项  | 说明         |
| :--: | ---------- |
|  -z  | 字符串长度是否为0  |
|  -n  | 字符串长度是否不为0 |
| ==或= | 是否相等       |
|  !=  | 是否不相等      |

注意：

- 使用`-n`在`[]`结构中测试必须要用`" "`把变量引起来或使用`[[ ]]`。
- 判断是否相等时，在`=` 、`==`或`!=`的两侧一定要有空格（`=`两侧不加空格是赋值）。
- 最好不要使用`=`或`!=`对数值进行判断（会被当作字符串进行对比）。

提示：判断字符串是否为空最可靠的方法：`"x${value}" == "x"`

## 布尔运算符

非运算：`! 表达式`；与/或运算：`表达式1 选项 表达式2` ，根据各表达式情况判断，返回true或false。

- !    非运算
- -o    或运算
- -a    与运算

## 逻辑运算符

`表达式1 选项 表达式2`

- &&    逻辑与
- ||    逻辑或

## 文件测试运算符

### 文件类型

` 选项 文件名`根据各选项，判断文件的某种情况，返回true或false。

| 选项 | 说明                                   |
| :--: | --------------------------------------|
|  -e  | 判断文件是否存在                         |
|  -f  | 判断文件是否存在，且是否为**普通**文件      |
|  -b  | 判断文件是否存在，且是否为**块设备**文件    |
|  -c  | 判断文件是否存在，且是否为**字符设备**文件   |
|  -d  | 判断文件是否存在，且是否为**目录**文件      |
|  -L  | 判断文件是否存在，且是否为块**符号链接**文件 |
|  -p  | 判断文件是否存在，且是否为**管道**文件      |
|  -s  | 判断文件是否存在，且是否为非空             |
|  -S  | 判断文件是否存在，且是否为**套接字**文件    |

### 文件权限

`选项 文件名`根据各选项，判断某项权限的情况，返回true或false。

|  选项  | 说明                  |
| :--: | ------------------- |
|  -r  | 判断文件是否存在，且是否有读权限    |
|  -w  | 判断文件是否存在，且是否有写权限    |
|  -x  | 判断文件是否存在，且是否有执行权限  |
|  -u  | 判断文件是否存在，且是否有SUID权限 |
|  -g  | 判断文件是否存在，且是否有SGID权限 |
|  -k  | 判断文件是否存在，且是否有SBit权限 |

###　文件对比

`文件名1 选项 文件名2`根据各选项，将第一个文件和第二个文件对比，判断对比情况，返回true/false。

|  选项  | 说明                       |
| :--: | ------------------------ |
| -nt  | 判断文件修改时间是否更新             |
| -ot  | 判断文件修改时间是否更晚             |
| -ef  | 判断文件的Inode是否一致（一致则为同一文件） |

# 正则表达式

这里不详述正则表达式相关内容，具体参看正则表达式和相关工具文档。

**正则表达式与[通配符](#通配符)**：

正则表达式是**包含匹配**，用于**文件内容**匹配；通配符是**完全匹配**，多用于**文件名**匹配。

- 支持正则：grep 、cut、sort、awk、sed、uniq
- 只支持通配符不支持正则：find、cp、ls、rm

应注意以下特殊字符的使用区别：

- `$`  shell中用作变量引用的时置于变量名前的标志符号；正则中表示字符串末尾。
- `*`  通配符中可单独使用，代表任意个数字符；**正则中不能单独使用**，表示重复前面的内容任意次。
- `?`  通配符中可单独使用，代表1字符；**正则中不能单独使用**，表示重复前面的内容0次或1次。

# 测试表达式

各类参见运算符号（除算术运算）中各个运算符使用说明：[数值关系判断](#关系运算符)、[字符串运算符](#字符串判断)、[布尔运算符](#布尔值判断)、[逻辑运算符](#逻辑判断)和[文件测试运算符](#文件判断)。

测试表达式会返回状态码（参看[预定义变量](#预定义变量)中的`$?`），0表示执行正确（true），1执行错误（false）。

- `test`关键字：`test 表达式`
- 单中括号`[ ]`和双中括号`[[ ]]`：`[ 表达式 ]` 和`[[ 表达式 ]]`
  - **`[ ]`在参数只是一个变量时，会把变量当字符串** 。（类似单双引号）
  - **`[[ ]]`可以使用`&&`  `||`  `<`  `>` 操作符**而`[ ]`中不可以。
  - 这两个命令作用同`test`（相当于是`test`的别名）。
  - 表达式与括号`[]`或`[[ ]]`之间**必须有空格** ，因为`[`和`[[`是linux内部命令（不过，算数运算中的`$[]`不需要有空格）。


# 流程控制

- **在关键字（如if）和中括号`[ ]`或`[[ ]]`之间必须要有空格** 。
- 如果两条命令写在一行，每条命令后面需要添加`;`进行间隔。

## 分支

### 单分支

```shell
if [ expression ]
then
	#some codes
fi
#或者这样写
if [ expression ]; then
	#some codes
fi
```
### 双分支

```shell
if [ expression ]
then
	#some codes
else
	#some codes
fi
```
### 多分支
#### 多分支if
```shell
if [ expression ]
then
	#some codes
elif [ expression ]
then
	#some codes
else
	#some codes
fi
```
#### 多分支case
```shell
case var in
value1)
	#some codes
	;;  ##;;跳出（相当于break）
value2 | value3)   #可以使用逻辑符号
	#some codes
	;;
*)	#最后一个默认分支的值使用*
	#some codes
;;
esac
```
## 循环

- 跳出循环：`break`
- 结束当前迭代，进入下一次迭代：`contiune`
- 循环的输入输出重定向：在`done`后面添加命令，例如`done > output.txt` `done | wc -l`
- 后台执行重定向：在`done`命令后面添加`&`
- `getops`根据用户指定的每个选项执行所需要的操作，没有找到要求的参数，它会将问号保存到变量中并向标准错误中输出错误信息。

### for循环

```shell
for var in value1 value2 value3
#for var in ${arr[*]}  #数组
#for var in $(cat testfile)  #从文件中获取变量列表

#也可以这样写，注意：shell中不能写i+=1
for ((i=1;i<=100;i=i+1))
do
	#some codes
done
```

### while循环和util循环

- while循环：expression中条件为真时进行循环：

```shell
while [ expression]
do
	#some codes
done
```

- until循环：**与while相反**，expression中条件为**假**时进行循环：

```shell
util [ expression ]
do
	#some codes
done
```
# 函数

## 声明和调用

```shell
#声明
function fn () {
    # action
    return <int>;
}
#调用
fn [参数] [参数] [...]
```

- `function`关键字和函数名后面的小括号可以省略。
- 函数名中的小括号中不能写参数，使用参数参看下面的[函数参数](#函数参数)。
- 参数返回，可以显示加`return` 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255）
- 函数调用的参数写在函数名后即可（空格隔开）。

## 返回值

- echo输出返回值，从标准输出中获取返回的值。

  ```shell
  function getVal(){
      echo 'hello shell'
  }
  str=$(getVal)  #hello shell
  ```

- ruturn返回状态码

  返回的状态码只能是0 ~ 255，上一条命令的状态码为`$?`。

  *如果只有true和false状态，一般约定以0表示true，1表示flase。*

  ```shell
  function getVal(){
      return 255
  }
  getVal
  echo $?   #255
  ```

- 赋值给全局变量：将要返回的内容写到一个全局变量中。

  ```shell
  function getVal(){
      str="a global var"
  }
  getVal
  echo $str   #a global var
  ```

## 参数

### 传入参数使用

#### 预定义变量和位置参数变量

参看上文[预定义变量](#预定义变量)和[位置参数变量](#位置参数变量)

### getopts/getops



#### shift向左移动位置参数

shift命令位置参数向左移动，也就是最后一个参数会被丢弃。

示例脚本`run`：

```shell
#!/bin/bash
while [ $# != 0 ]
do
echo "prama is $1,prama size is $#"
shift
done
```

运行`run a b c`，返回内容为：

> prama is a,prama size is 3
> prama is b,prama size is 2
> prama is c,prama size is 1
>
>

### 参数替换

以下写法中，`param`为参数名，`val`为新的值。

| 语法            | 关键符号 | 参数值不为空 | 参数值为空                      |
| :-------------- | :------: | :----------- | ------------------------------- |
| `${param:-val}` |   `-`    | 使用原值     | 使用新值                        |
| `$param:=val}`  |   `=`    | 使用原值     | 为参数对应变量赋予新值 使用新值 |
| `${param:?val}` |   `?`    | 使用原值     | 发返回错误　打印错误信息        |
| `${param:+val}` |   `+`    | 使用新值     | 使用原值——空值                  |

```shell
test=''
echo "${test:-hello} -- $test"  #hello --

echo "${test:+hello} -- $test"  #hello --  hello

#此时test已经被上条命令赋值为hello
echo "${test:?bye} -- $test"  #hello -- hello  #test不为空仍用原值
test=''　#置空test
echo "${test:?hello} -- $test"  #错误　输出提示 bash: test: hi

#test仍为空
echo "${test:+bye} -- $test"  # --   原值为空使用原空值
test=hello
echo "${test:+bye} -- $test"  #bye -- hello  原值不为空　使用新值
```

截取字符串

```shell
${param:start:length}
```

`start`为起始字符序号，`length`为自`start`开始所截取的长度。如果**有冒号`:`但省略冒号后面的数字**，则`start`或`length`则默认取值为0。

```shell
str='hello'
echo "${test::5}"   #hello
echo "${test:0}"   #hello
echo "${test:0:}"   #hello
```





${!prefix*}
${!prefix@}

将带有前缀为prefix的参数名打印出来
${!name[@]}
${!name[*]}



${}带正则匹配的几种表达式：
${parameter#word}
${parameter##word}

从头开始扫描word，将匹配word正则表达的字符过滤掉

#为最短匹配，##为最长匹配
${parameter%word}
${parameter%%word}

从尾开始扫描word，将匹配word正则表达式的字符过滤掉

%为最短匹配，%%为最长匹配

${parameter/pattern/string}
${parameter//pattern/string}

将parameter对应值的pattern字符串替换成为string字符串

/表示只替换一次

//表示全部替换



## 外部脚本

### 引用外部脚本

两种书写格式：

- `. filename `      注意点号`.`和文件名中间有一空格
- `source filename`    （如` source .test.sh` ）

**注：**被包含的文件可以没有可执行权限。

### 执行外部脚本

- **fork**——直接在脚本里面执行脚本

  将新开一个shell来执行，子 Shell 可以从父 Shell 继承环境变量，但是子 Shell 中的环境变量不会带回给父 Shell。

  - 如果脚本有执行权限：`path/to/file.sh`
  - 如果没有执行权限：`sh path/to/file.sh`——建议

- **exec**： `exec path/to/file.sh`

  不需要新开一个子 Shell 来执行被调用的脚本，被调用的脚本与父脚本在同一个 Shell 内执行。

- **source**: `source path/to/file.sh`

  同一个 Shell 中执行，在被调用的脚本中声明的变量和环境变量, 都可以在主脚本中进行获取和使用，相当于合并两个脚本在执行。

# exit退出状态码

`exit n` n为返回的状态码，如果不指定，则根据情况返回0或1