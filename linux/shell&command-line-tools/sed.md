# 简介

sed是一个按行处理的流编辑器（stream editor），它把当前要处理的行读取到临时缓冲区中（称为“模式空间”，pattern space），按指定的操作命令处理并输出到标准输出。

 [sed手册](http://www.gnu.org/software/sed/manual/sed.html)

## 语法格式

语法格式：

```shell
sed   [options]  <sed commands>   <file or stdin>

sed 选项 'sed子命令' 文件名
sed 选项 'sed子命令' <  标准输入
#可以指定多个 -e 和 -f 指定多个命令或包含sed子命令的文件
sed 选项 -e 'sed子命令1' -e '子命令2' 文件名
sed -f sed命令文件 文件名
sed -f sed命令文件1 -f sed命令文件2 文件名
```

**注意：sed不能编辑内容为空的文件（或标准输入）。**

## 常用选项

- `-e`或`--expression=命令`  多点编辑（可在执行多个子命令时使用）
- `-f`或`--file=脚本文件`  从文件中读取sed子命令（事先将sed子命令写入文件中供读取调用）


- `-i`或`--in-place[=SUFFIX]`  编辑文件内容并取代原文件（如果指定扩展名则备份文件）
- `-n`或`--quiet`或`--silent` 安静模式 仅显示处理后的结果
- `-l`或`--line-length=N`   指定换行期望长度
- `-r`或`-regexp-extended`  启用扩展的正则表达式
- `-u`或`–unbuffered`  从输入文件中加载最少的数据，并更频繁的刷出到输出缓冲区
- `-z`或`–null-data`  使用NULL字符分割行（默认每一行使用换行符分割）

# sed子命令

子命令内容分为两部分：

- [匹配规则](#匹配规则)——匹配被操作的内容

  **匹配规则不一定是必须的，如果没有该部分就表示全文匹配（匹配所有行）**，例如：

  ```shell
  sed -n "p" /etc/profile  #打印所有行的内容
  sed -s "s/^#/##/" /etc/profile  #替换所有行中以#开头的字符为##
  ```

- [处理动作](#处理动作)——处理要被操作的内容

  处理动作分为：**处理命令**和**要被处理**

  对于编辑相关命令，编辑命令之后需要有要变更为的内容。

  **匹配规则**、**处理命令（处理选项）**和**要变更为的内容**之间可以没有空格，不过最在编辑命令和要变更为的内容之间添加空格，以增加可读性。

  ```shell
  sed -i "/^123/c456" test 
  sed -i "/^123/ c 456" test  #c和456直接添加空格增加可读性
  ```

sed根据匹配规则从文件流中读取行到模式空间，处理完该行后清空模式空间，再读取下一个匹配的行到模式空间进行处理。

其他注意事项：

- 子命令前使用`!`表示取反操作

- 子命令最好使用`" "`包裹

  不使用引号时变量中如果含有空格或换行符等符号时会处理失败。示例：

  > ```shell
  > ~ $ echo "123" > test
  > ~ $ a="a b c "
  > ~  sed -i s/123/a/ test
  > sed：-e 表达式 #1，字符 7：未终止的“s”命令
  > ~ $  sed -i "s/123/$a/" test && cat test
  > a b c
  > ```

  单引号包裹时对变量还需特殊处理（如下文），否则`$`被当成普通字符处理。

- 引用变量

  - 匹配规则部分引用变量：直接使用`$var`即可。

    sed匹配规则中，`$`仍可表示行尾这个特殊意义。

    ```shell
    a=export
    sed -n "/$a/ p" /etc/profile
    ```

  - 处理动作部分引用变量（”要变更为的内容“部分）

    **要保持变量名字符本身而不是使用变量的值，在`$`前使用`\`转义。**

    - 子命令使用双引号包裹，则变量外使用双引号或者不使用引号；
    - 子命令使用单引号，则变量外使用单引号：

    ```shell
    sed -i "/^TOPdir\s/c TOPdir = $(pwd)" Make.include
    #建议用下面的方法
    sed -i '/^TOPdir\s/c TOPdir = '$(pwd)'' Make.include
    ```

## 匹配规则

### 行匹配

匹配特定的某行或多行，匹配的行将交由后续的操作命令（如`p`、`c`等）处理。

- 单行
  - 第n行：数字n
  - 首行：`^`
  - 末行：`$`

  注意，写到`//`中的`/^/`表示行首，写到`//`中的`/$/`表示行首，此为正则表示中的`$`之意。
  
- 单行或多行

  - 符合某个正则匹配的行：`/pattern/`

  - 两行之间的所有行（包行这两行）

    `起始行匹配规则,结束行匹配规则`

    - 行数和行数：`数字m,数字n`（第m到n行）
    - 行数和正则：`/pattern/,n`和`n,/pattern/`
    - 正则和正则：`/pattern1/,/pattern2/`

- 除了某行的行：在规则后面添加空格，然后添加`!`，匹配不与前面规则匹配的行。

  例如`$ !` （注意`$`和`！`之间有空格），表示除了最后一行。

  以上规则后面均可添加`!`取反。

- 隔行处理：`数字n~数字x` （从第n行开始处理，下一次处理当前行后面的x行）

  *例如`1~2`表示从第1行开始处理，下一次处理当前行后面的第2行，也就是依次处理1，3，5，7……行*

### 匹配标记

匹配行中的**符合匹配标记规则的内容才会被交由后方的处理动作命令处理**。

- 缺省 匹配行中第1个符合匹配条件的内容 （即不写任何标记时的处理给呃）
- `数字n`  匹配行中第n个符合匹配条件的内容
- `g` 匹配行中所符合匹配条件的内容
- `i`  匹配时忽略大小写
- `w`  将模版空间中新的数据写入指定的文件

### 匹配中的特殊字符

如果sed命令未使用`-r`选项，则sed子命令中使用类似正则表达式特殊字符，与常规正则表达式有所不同。

故而建议**欲使用正则匹配，务必为sed命令添加`-r`或`-E`选项。**



- 不能使用`\d`、`\w`等正则元字符，只能以`[0-9]`、`[a-zA-z]`替代。
- **某些特殊字符与常规正则表达式特殊字符相反**：直接使用时仅表示字符本身的符号意义，在其前面添加`\`才表示一种特殊的匹配含义。

    | 匹配规则          | 正则中特殊字符 | sed中使用该特殊字符 |
    | ----------------- | :------------: | :-----------------: |
    | 匹配0个或1个字符  |      `?`       |        `\?`         |
    | 匹配1个及以上字符 |      `+`       |        `\+`         |
    | 子表达式          |      `()`      |       `\(\)`        |
    | 重复匹配          |      `{}`      |       `\{\}`        |
    | 逻辑或            |      `|`       |        `\|`         |

    提示：shell中使用`\n`表示回溯引用第n个子表达式（n为一个自然数，其中n为0时表示整个表达式本身）。

## 处理动作

### 处理命令

多个命令需要放入`{}`中，命令之间使用`;`分隔，也可以使用换行符号分隔（每行一种命令）。

```shell
sed -n '{p;n}' test
#或
sed -n '{p
=}' test
```

- 打印

  默认情况下**文件内容每行被打印两次**（其也被称为回顾打印），使用`-n`（或`--quiet`或`--silent`） 参数则仅将**匹配的内容打印一次**。

  - 打印文本行  `p`
  - 打印行号 `=`
  - 列出行 `l`

- 替换

  - 替换行  `c`

     > c 要被替换为的新内容行

  - 替换单个字符  `y`

     > y /旧字符/新字符/

     可以一次匹配替换多个，将a替换成A，b替换成B，0替换成1。

     > y/ab0/AB1/

  - 全文替换字符串  `s`

     注意只会替换匹配的行中的第一个符合的字符串，可使用`g`替换该行所有符合的字符串。
     
     > s/旧字符串/新字符串/
     >
     > s/旧字符串/新字符串/g
     
     注意，sed每次处理一行数据后，都会在行尾自动添加**trailing newline**，其实就是行的分隔符即换行符，因此直接使用`s/\n//`全文替换`\n`是无效的。但可以通过模式空间等高级方法来完成。
     
     技巧，通过sed将行尾`$`替换，再使用echo完成`\n`的替换：
     
     ```shell
     #将换行符号替换成,
     echo $(sed  -e "s/$/,/" flie) > file\
     #将换行符号替换成实际的\n字符
     echo $(sed  -e "s/$/\\\n/" flie) > file
     ```

- 新增行

  - 行上方插入(insert)：`i`

    > i 新加内容xxx

  - 行下方追加(append)：`a`

    > a 新加内容xxx

- 删除行  `d`

- 读取其他文件内容追加  `r`

  > r newfile.txt

### 处理选项

- `\n`  代表第n个子表达式匹配的内容
- `&`  代表匹配的整个内容
- `\L`  将在其后的替换部分转换成小写字母
- `\l`：将下一个字符转换成小写字母
- `\U`：将在其后的替换部分转换成大写字母
- `\u`：将下一个字符转换成大写字母
- `\E`：停止由`\L`或`\U`指示开始的大小写转换


```shell
sed -i "s/aaa/bbb/g" test  #替换test中所有aaa为bbb
sed -i "/hello/ s/aaa/bbb/" test  #替换test中含有hello的行的aaa为bbb
sed 's/^bbb/#&/' test  #为bbb开头的行前面添加#号
sed 's/^#\(bbb\)/\1/' test  #去掉符合匹配内容的行前面的#号

sed -i '2!d' filename #除了第二行外均删除
sed  -i -e '1a hello' -e '2i world' filename  #第一行后插入 第2行前插入
sed -i -e '1d' -e '2c new-world' filename  #删除第一行 替换第2行
```

## 模式空间与保持空间

模式空间（pattern space）和保持空间（hold space）均是处理文本内容行的**临时缓冲区**：

- 模式空间：sed的工作空间，根据匹配模式将要处理的行读入模式空间进行处理，其中的内容定向到标准输出，并**自动清空**。

- 保持空间：sed的内容**不会主动清空**，也不会主动打印到标准输出，**需要sed命令进行处理**。

空间内容操作命令
- `N`  将下一行内容纳入当前缓冲区

  - `h`  将模式空间复制到保持空间
  - `H`  将模式空间追加到保持空间
  - `g`  将保持空间复制到模式空间
  - `G`  将保持空间附加到模式空间
  - `x`  交换模式空间和保持空间的内容

多行

- N  将数据流中的下一行加进来创建一个多行组来处理
- D  删除多行组中的一行
- P  打印多行组中的一行

操作匹配行的下一行`匹配规则{n;处理动作}`

```shell
sed -s '/^test/{n;d}'  #删除以test开头的行的下一行
```

将下一行内容

## 分支和测试

- 分支branch：`b`
- 测试test：`t`
- 标签(label)：标签名字任意以":"开头，第二个字符不能是空格，长度不超过7个字符，如":top"。

```shell
#将所有换行符换成实际的\n字符
sed ":tag;N;s/\n/\\\n/;b tag" file
```

