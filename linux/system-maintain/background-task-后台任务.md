# 前后台任务管理

对于一个正在执行的前台任务（例如`ping z.cn`），可使用以下命令管理：

- <kbd>ctrl</kbd> <kbd>z</kbd>  挂起(suspend)进程，即将一个正在前台执行的命令放到后台，并且暂停。使用`fg`或`bg`可以继续执行。

- <kbd>ctrl</kbd> <kbd>c</kbd>  终止正在前台执行的命令。

- `jobs`  当前终端正在运行的进程

  选项：

  -  `-l`	在正常信息基础上列出进程号
  - `-n`	仅列出上次通告之后改变了状态的进程
  - `-p`	仅列出进程号
  - `-r`	限制仅输出运行中的任务
  - `-s`	限制仅输出停止的任务

- `fg`  将后台运行的进程任务放到前台运行

  如果后台中有多个命令，可以用 `fg %后台任务编号`调用指定编号的任务。

  ```shell
  fg
  fg %2
  ```

- `bg`  将任务放置到后台执行，如果任务是暂停状态，也会被启动起来。

  如果后台中有多个暂停的命令，可以用 `bg %后台任务编号`调用指定编号的任务。

# 任务后台运行

## 会话退出与中断信号

断开提交命令的会话后，提交的命令会因为SIGHUP信号而自动退出：

> 1. 用户准备退出 session
> 2. 系统向该 session 发出`SIGHUP`信号
> 3. session 将`SIGHUP`信号发给所有子进程
> 4. 子进程收到`SIGHUP`信号后，自动退出

欲在退出会话（自动断开话主动登出）后，仍让任务在后台运行可以使用以下解决思路：

- 让进程忽略 HUP 信号
- 让进程运行在新的会话里从而成为不属于该终端（执行命令的终端）的子进程

## 保持后台运行

- `&`后台进程脱离当前shell

  `&`后台运行的进程为当前shell的子进程，如果当前shell进程被直接杀死——接收到`SIGHUP`信号（除了直接kill进程外，在图形界面中直接关闭终端模拟器程序以及网络中断也会收到该信号），后台子进程将因为父进程退出而退出。

  如果在**提交`&`后台命令后**，**使用exit（或<kbd>ctrl</kbd>  ）退出当前终端**，该后台进程就会脱离当前shell的父进程将变成进程号为`1`的进程的子进程，从而**进程保持运行**。

  ```shell
  ping z.cn &
  #如果提交的命令有输出信息干扰，可使用重定向将其定向到某个文件中
  ping z.cn >> ping.log &
  ```

- `nohup`

  让进程与父Shell完全脱离，并**忽略HUP信号**。

  ```shell
  nohup ping z.cn &
  ```

- 子shell`()`+`&`

  将一个或多个命名包含在`()`中就能让这些命令在**子 shell 中运行**，将命令连同`&`也放入`()`内之后，该命令就**不再是当前终端进程的子进程**。

  ```shell
  (ping z.cn &)
  ```

- `setsid`

  让提交的命令分配的进程不成为当前终端的子进程。因此退出终端后，提交的命令不会收到HUP信号。

  ```shell
  setsid ping -c 10 z.cn
  #不过当前进程的输出还是会打印在终端 可以将其重定向
  setid ping -c 10 &> ping.log
  ```

- `disown`

  如果想要命令后台运行，但是未加以上任何后台处理方式就已经提交了命令，可以使用作业管理和`disown`解决该问题。

  

  - 如果提交命令时已经用“&”将命令放入后台运行，直接使用`disown`即可。

    1. `jobs`命令查看该后台任务的作业号(jobID)
    2. `disown -h %<jobID>`

  - 如果提交命令时未经用“&”将命令放入后台运行，可以先挂起任务，而后`bg`放入后台，最后再使用`disown`

    1. <kbd>Ctrl</kbd> <kbd>z</kbd>挂起任务
    2. `jobs`命令查看挂起的作业号(jobID)
    3. `bg`放入后台执行
    4. `disown -h %<jobID>`

    ```shell
    ping z.cn > ping.log
    #ctrl z挂起
    jobs
    bg #作业不止一个时 要使用 bg %作业号
    disown -h %1
    ```

  disown选项：

  - `-a`	如果不提供 JOBSPEC 参数，则删除所有任务
  - `-h`	标识每个 JOBSPEC 任务，从而当 shell 接收到 SIGHUP信号时不发送 SIGHUP 给指定任务
  - `-r`	仅删除运行中的任务

- `tmux`、`screen`等工具

  用于大量运行后台任务的场景，功能强大。

- 此外，对于要时刻在后台运行的进程，尤其是希望其在系统启动后总是自行后台运行，可使用systemd或crontab。

# 附

## 进程、线程、服务和任务

- 进程（process）：**运行中的应用程序**，每一个进程都有自己独立的内存空间。

  一个应用程序可以同时启动多个进程。

- 线程（thread）：**操作系统能够进行运算的最小单位**。

  线程被包含在进程之中，是进程中的实际运行单位。一条线程是指进程中的一个单一顺序的控制流，一个进程中可以并行多个线程，每条线程并行执行不同的任务。同一进程中的所有线程在同一块地址空间中工作。

- 服务（service）即守护进程：一直运行在系统后台的进程。

- 任务（task）：一个很宽泛的概念，由软件完成的一个活动，为达到某一目的而进行的一系列的操作，一般由很多个进程相互作用完成。

## 进程类型

- 交互进程：是由一个Shell启动的进程。可以在前台运行，也可以在后台运行。
- 批处理进程：和终端没有联系，是一个进程序列。
- 监控进程（系统守护进程）：Linux系统启动时运行的进程，常驻于后台。

## 进程组与会话

- 进程组(process group)：一个或多个进程的集合。

  每个进程组称为一个工作(job)。

  进程组有一个组长进程，组长进程ID为进程组ID，该组的其余进程为组长进程的子进程，组长进程即为其他子进程的父进程。

  只要进程组中有一个进程存在，进程组就存在，与组长进程是否终止无关。

  进程组生存期: 进程组创建到最后一个进程离开(终止或转移到另一个进程组)

- 会话(session)：一个或多个进程组的集合。

  会话是由其中的进程建立，该进程为会话的领导进程(session leader)。

  会话领导进程的PID成为识别会话的SID(session ID)。

