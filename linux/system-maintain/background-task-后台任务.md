# 前后台任务管理

以下前后台任务的进程是当前提交命令的终端的子进程。

- `&`   用在一个命令的最后，可将其放到后台执行。

  ```shell
  ping z.cn &
  #如果提交的命令有输出信息干扰，可使用重定向将其定向到某个文件中
  ping z.cn >> ping.log &
  ```

- <kbd>ctrl</kbd> <kbd>z</kbd>  挂起(suspend)进程，即将一个正在前台执行的命令放到后台，并且暂停。

- <kbd>ctrl</kbd> <kbd>c</kbd>  终止正在前台执行的命令。

- `jobs`  列出后台命令（每个后台任务都有一个编号）

  选项：

  -  `-l`	在正常信息基础上列出进程号
  - `-n`	仅列出上次通告之后改变了状态的进程
  - `-p`	仅列出进程号
  - `-r`	限制仅输出运行中的任务
  - `-s`	限制仅输出停止的任务

- `fg`  后台中的命令**调至前台**继续执行

  如果后台中有多个命令，可以用 `fg %后台任务编号`调用指定编号的任务。

  ```shell
  fg
  fg %2
  ```

- `bg`  将一个在后台暂停的命令，变成**继续后台执行**

  如果后台中有多个暂停的命令，可以用 `bg %后台任务编号`调用指定编号的任务。

# 任务后台运行

在命令后添加`&`可使其后台运行，但是退出此次运行该命令的终端后，该命令也会中止运行。

## 会话退出与中断信号

断开提交命令的会话后，提交的命令会因为SIGHUP信号而自动退出：

> 1. 用户准备退出 session
> 2. 系统向该 session 发出`SIGHUP`信号
> 3. session 将`SIGHUP`信号发给所有子进程
> 4. 子进程收到`SIGHUP`信号后，自动退出



欲在退出会话（自动断开话主动登出）后，仍让任务在后台运行可以使用以下解决思路：

- 让进程忽略 HUP 信号
- 让进程运行在新的会话里从而成为该终端的子进程

## 保持后台运行

- `nohup`

  让进程与父Shell完全脱离，并**忽略HUP信号**。

  ```shell
  nohup ping z.cn &
  ```

- 子shell`()`+`&`

  将一个或多个命名包含在`()`中就能让这些命令在**子 shell 中运行**，将命令连同`&`也放入`()`内之后，该命令就**不再是当前终端进程的子进程**。

  ```shell
  (ping z.cn &)
  ```

- `setsid`

  让提交的命令分配的进程不成为当前终端的子进程。因此退出终端后，提交的命令不会收到HUP信号。

  ```shell
  setsid ping -c 10 z.cn
  #不过当前进程的输出还是会打印在终端 可以将其重定向
  setid ping -c 10 &> ping.log
  ```

- `disown`

  将进程从当前shell的jobs列表中移除， 但依然与Shell有连接（不再为当前shell的子进程）。

  选项：

  - `-a`	如果不提供 JOBSPEC 参数，则删除所有任务
  - `-h`	标识每个 JOBSPEC 任务，从而当 shell 接收到 SIGHUP信号时不发送 SIGHUP 给指定任务
  - `-r`	仅删除运行中的任务

  如果未加任何（以上）处理而直接提交了命令，可以使用disown以避免HUP信号的影响。

  ```shell
  ping z.cn >> ping.log  &  #直接提交了命令 而未使用nohup/setsid/子shell等配合&后台执行
  jobs
  disown -h %1
  ```

  如果提交命令时未使用`&`将命令放入后台运行，可使用<kbd>Ctrl</kbd> <kbd>z</kbd> 和`bg`将其放入后台执行，再使用`disown`。

- `tmux`、`screen`等工具

  用于大量运行后台任务的场景，功能强大。

- systemd

# 附

## 进程、线程、服务和任务

- 进程（process）：**运行中的应用程序**，每一个进程都有自己独立的内存空间。

  一个应用程序可以同时启动多个进程。

- 线程（thread）：**操作系统能够进行运算的最小单位**。

  线程被包含在进程之中，是进程中的实际运行单位。一条线程是指进程中的一个单一顺序的控制流，一个进程中可以并行多个线程，每条线程并行执行不同的任务。同一进程中的所有线程在同一块地址空间中工作。

- 服务（service）即守护进程：一直运行在系统后台的进程。

- 任务（task）：一个很宽泛的概念，由软件完成的一个活动，为达到某一目的而进行的一系列的操作，一般由很多个进程相互作用完成。

## 进程类型

- 交互进程：是由一个Shell启动的进程。可以在前台运行，也可以在后台运行。
- 批处理进程：和终端没有联系，是一个进程序列。
- 监控进程（系统守护进程）：Linux系统启动时运行的进程，常驻于后台。

## 进程组与会话

- 进程组(process group)：一个或多个进程的集合。

  每个进程组称为一个工作(job)。

  进程组有一个组长进程，组长进程ID为进程组ID，该组的其余进程为组长进程的子进程，组长进程即为其他子进程的父进程。

  只要进程组中有一个进程存在，进程组就存在，与组长进程是否终止无关。

  进程组生存期: 进程组创建到最后一个进程离开(终止或转移到另一个进程组)

- 会话(session)：一个或多个进程组的集合。

  会话是由其中的进程建立，该进程为会话的领导进程(session leader)。

  会话领导进程的PID成为识别会话的SID(session ID)。

